I must say that even after having worked with the API for some time, I
still find it confusing.  Transcoders? Sessions? WireTemplates?  What
I *really* would like to be able to say is this:

"Hi, I'm interested in data sets having template ID 1234.  Whenever
such a data set comes along, please decode the values in that set as
follows:

  * a sourceIPv4Address please place at offset 24 (or at this pointer)
  * a deltaPacketCount please place at offset 28 (or at that pointer),
    but only the least significant 4 bytes

After you're done decoding this, please call my callback
function. Also, here is a mutex that belongs to me and that you should
down() before you begin writing stuff into my private parts (ahem),
and that you should up() after calling the callback."

In other words, I'm thinking of an API like this:

class RecordUser {
public:
  virtual void decoding_finished() = 0;
};

class RecordUserRegistrar {
public:
  void register(uint32_t template_id,
                RecordUser& user,
                void* base,
                std::list<std::pair<const InfoElement*, off_t offset>,
                mutex& m);
};

Classes wanting to use the registrar would then derive from RecordUser
(cleverly exploiting the new C++ initialisation rules):

class HiThere : public RecordUser {
public:
  HiThere() {
    InfoModel* m = ...;
    const RecordUserRegistrar* r = ...instance();

    r->register(1234, *this, this,
          { { m->lookupIE("sourceIPv4Address"), &s) },
            { m->lookupIE("deltaPacketCount"), &c) },
          }, m);
  }

  void decoding_finished() {
    ... Do whatever needs to be done with the information
  }

private:
  uint32_t s;
  uint32_t c;
  mutex m;
};


And there would be some central dispatcher that would do the
dispatching according to the template id, kinda like this:

void SomeClass::decode() {
  uint32_t tid = ...;

  for (auto i = registered_users.find(tid); i != multimap::end; ++i) {
    i->mutex.down();
    for (auto ie = i->ies.begin(); ie != i->ies.end(); ++i)
      ....decode(ie->iename(), ie->offset(), ie->len());
    i->user.decoding_finished();
    i->mutex.up();
  }
}

That should be reasonably compact and fast, and it would solve the
concurrency problems also by having one central point at which to
down() and up() the respective mutexes.

I was trying to find a good way to avoid copying items, just working
with pointers, and I think I can do that.  Of course for unsignedxx,
copying them is not a big deal, but for the varlen[65535] it might be
more advisable to work directly with the raw data. The question is,
would that be useful?

Stephan 
