I must say that even after having worked with the API for some time, I
still find it confusing.  Transcoders? Sessions? WireTemplates?  What
I *really* would like to be able to say is this:

class IEOnWire {
  // ...
private:
  const InfoElement* ie;
  size_t ie_length;  // Length of this IE on the wire
  void* p;
};

For example:

sourceIPv4Address, 4
destinationIPv4Address, 4
informationElementName, kVarlen
informationElementSemantics, 1
informationElementRangeEnd, 4
informationElementUnits, 2

Why is the length for informationElementName kVarlen? Because it's a
Varlen.  Offset computation would then be as follows:

First, set up record offsets for the current record:

  /* Can also reuse an array that's already there, since all values in
   * the array will be overwritten. */
  size_t* record_offset = new size_t[n_ies];
  size_t current_offset = 0;

  for (unsigned int i = 0; i < n_ies; i++) {
    record_offset[i] = current_offset;
    if (ie_descriptions[i].ie_length == kVarlen)
      current_offset = 0;
    else
      current_offset += ie_descriptions[i].ie_length;
  }

Then update them whenever a Varlen has just been successfully
decoded:

  if (isVarlen((ie_descriptions[i].ie)) {
    size_t next_offset = current_offset + ie_length;
    for (unsigned int j = i + 1;
         j < n_ies && !isVarlen(ie_descriptions[j].ie);
         j++) {
      record_offset[j] += next_offset;
      next_offset += ie_descriptions[j].ie_length;
    }
  }

Decoding could be done with an array of functions like this:

static void (or int, for error returns)
decode_uint32(void* ret, const uint8_t** buf, const uint8_t* limit,
              size_t wire_length) {
  uint32_t r = 0;
  for (unsigned int i = 0; i < wireLength; i++)
    r = (r << 4) | (*buf)[i];
  *static_cast<uint32_t*>(ret) = r;
  *buf += wire_length;
}

static void
decode_double(void* ret, const uint8_t** buf, const uint8_t* limit,
              size_t wire_length) {
  /* Only IEEE floats (32 bit) or doubles (64 bit) allowed */
  assert(wire_length == 4 || wire_length == 8);

  union {
    float f;
    double d;
    uint8_t b[8];
  } val;

  // Assume that 0.0F and 0.0 and '\0' are represented as all zeros
  // (which is not mandated by the C++ standard).
  memset(val.b, sizeof val, '\0'); // or val.d = 0.0;

  for (unsigned int i = 0; i < wire_length; i++)
    val.b[i] = (*buf)[i];

  if (wire_length == 4) // There's a float on the wire
    *static_cast<double*>(ret) = val.f;  // Implicit conversion to double
  else // There's a double on the wire
    *static_cast<double*>(ret) = val.d;

  *buf += wire_length;
}

static void
decode_varlen(void* ret, const uint8_t** buf, const uint8_t* limit,
              size_t wire_length) {
  size_t varlen_length = ...;
  // decode the varlen
  *buf += varlen_length;
}

also, one can skip:

static void
skip_fixlen(void* ret, const uint8_t** buf, const uint8_t* limit,
            size_t wire_length) {
  assert(ret == 0);
  *buf += wire_length;
}

static void
skip_varlen(void* ret, const uint8_t** buf, const uint8_t* limit,
            size_t wire_length) {
  assert(ret == 0);
  size_t varlen_length = ...;
  *buf += varlen_length;
  // recompute offsets...
}


The whole decoding could then be described by an array of function
pointers:

void* ret[];
void (*decode[])(void* ret, const uint8_t** buf, const uint8_t* limit,
                 size_t wire_length);

// ...

uint8_t* buf = ...;
for (unsigned int i = 0; i < n_ies; i++) {
  assert (*buf is in range);
  assert (*buf + ie_descriptions[j].ie_length is in range);
  decode[i](ret[i], &buf, buf + record_length, ie_descriptions[j].ie_length);
}

CONTENT IS OBSOLETE BEYOND THIS POINT! ARCHIVED ONLY FOR
POSSIBLE HISTORIC SIGNIFICANCE


  * a sourceIPv4Address please place at offset 24 (or at this pointer)
  * a deltaPacketCount please place at offset 28 (or at that pointer),
    but only the least significant 4 bytes

After you're done decoding this, please call my callback
function. Also, here is a mutex that belongs to me and that you should
down() before you begin writing stuff into my private parts (ahem),
and that you should up() after calling the callback."

In other words, I'm thinking of an API like this:

class RecordUser {
public:
  virtual void decoding_finished() = 0;
};

class RecordUserRegistrar {
public:
  void register(uint32_t template_id,
                RecordUser& user,
                void* base,
                std::list<std::pair<const InfoElement*, off_t offset>,
                mutex& m);
};

Classes wanting to use the registrar would then derive from RecordUser
(cleverly exploiting the new C++ initialisation rules):

class HiThere : public RecordUser {
public:
  HiThere() {
    InfoModel* m = ...;
    const RecordUserRegistrar* r = ...instance();

    r->register(1234, *this, this,
          { { m->lookupIE("sourceIPv4Address"), &s) },
            { m->lookupIE("deltaPacketCount"), &c) },
          }, m);
  }

  void decoding_finished() {
    ... Do whatever needs to be done with the information
  }

private:
  uint32_t s;
  uint32_t c;
  mutex m;
};


And there would be some central dispatcher that would do the
dispatching according to the template id, kinda like this:

void SomeClass::decode() {
  uint32_t tid = ...;

  for (auto i = registered_users.find(tid); i != multimap::end; ++i) {
    i->mutex.down();
    for (auto ie = i->ies.begin(); ie != i->ies.end(); ++i)
      ....decode(ie->iename(), ie->offset(), ie->len());
    i->user.decoding_finished();
    i->mutex.up();
  }
}

That should be reasonably compact and fast, and it would solve the
concurrency problems also by having one central point at which to
down() and up() the respective mutexes.

I was trying to find a good way to avoid copying items, just working
with pointers, and I think I can do that.  Of course for unsignedxx,
copying them is not a big deal, but for the varlen[65535] it might be
more advisable to work directly with the raw data. The question is,
would that be useful?
